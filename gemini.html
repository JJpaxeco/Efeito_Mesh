<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:,">
    <title>Tecido Interativo - Verlet Physics</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }

        canvas {
            display: block;
        }

        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            user-select: none;
        }

        h2 { margin: 0 0 10px 0; font-size: 18px; color: #4deeea; }
        p { margin: 5px 0; font-size: 14px; }
     .highlight { color: #ff5e5e; font-weight: bold; }
    </style>
</head>
<body>

    <div id="instructions">
        <h2>Simulação de Tecido</h2>
        <p>1. <b>Mova o mouse</b> suavemente para gerar vento.</p>
        <p>2. Mova <b>rápido</b> para <span class="highlight">rasgar</span> a malha.</p>
        <p>3. <b>Clique direito</b> e arraste para cortar (faca).</p>
    </div>

    <canvas id="c"></canvas>

<script>
/**
 * SISTEMA DE FÍSICA VERLET
 * ------------------------
 * Implementação de dinâmica de tecidos focada em estabilidade e interação.
 */

// Configurações Físicas
const SETTINGS = {
    friction: 0.99,         // Resistência do ar
    gravity: 0.25,          // Força gravitacional por frame
    spacing: 8,             // Distância entre nós (resolução da malha)
    stiffness: 4,           // Iterações do solver (rigidez)
    tearDistance: 50,       // Distância máxima antes da ruptura
    mouseSize: 30,          // Raio de influência do mouse
    mouseStrength: 0.6,     // Força de vento suave
    mouseTearStrength: 4.0  // Multiplicador de força para rasgo rápido
};

// Variáveis Globais
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

// Estado do Mouse
const mouse = {
    x: undefined, // undefined evita interação inicial no canto 0,0
    y: undefined,
    px: undefined, // Posição anterior
    py: undefined,
    button: 0
};

// =========================================================
// CLASSES
// =========================================================

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.px = x; // Previous X
        this.py = y;
        this.pinned = false; 
    }

    update() {
        if (this.pinned) return;

        // 1. Calcular Velocidade (Verlet: atual - anterior)
        let vx = (this.x - this.px) * SETTINGS.friction;
        let vy = (this.y - this.py) * SETTINGS.friction;

        // 2. Salvar posição atual
        this.px = this.x;
        this.py = this.y;

        // 3. Aplicar Gravidade e Inércia
        this.x += vx;
        this.y += vy + SETTINGS.gravity;

        // 4. Interação com Mouse
        if (mouse.x!== undefined && mouse.y!== undefined) {
            const dx = this.x - mouse.x;
            const dy = this.y - mouse.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < SETTINGS.mouseSize) {
                // Cálculo de velocidade do mouse para detectar movimento brusco
                const mouseVx = mouse.x - mouse.px;
                const mouseVy = mouse.y - mouse.py;
                const mouseSpeed = Math.sqrt(mouseVx*mouseVx + mouseVy*mouseVy);
                
                const isCutting = mouse.button === 2; // Botão direito
                const isTearingMove = mouseSpeed > 15; // Velocidade limite

                if (isCutting) {
                    const force = (SETTINGS.mouseSize - dist) * 10;
                    const angle = Math.atan2(dy, dx);
                    this.px -= Math.cos(angle) * force;
                    this.py -= Math.sin(angle) * force;
                } else {
                    const forceMultiplier = isTearingMove? SETTINGS.mouseTearStrength : SETTINGS.mouseStrength;
                    const force = (SETTINGS.mouseSize - dist) / SETTINGS.mouseSize * forceMultiplier;
                    const angle = Math.atan2(dy, dx);
                    
                    this.px -= Math.cos(angle) * force;
                    this.py -= Math.sin(angle) * force;
                }
            }
        }
    }

    pin(x, y) {
        this.x = x;
        this.y = y;
        this.px = x;
        this.py = y;
        this.pinned = true;
    }
}

class Constraint {
    constructor(p1, p2) {
        this.p1 = p1;
        this.p2 = p2;
        this.length = SETTINGS.spacing;
    }

    resolve() {
        if (!this.p1 ||!this.p2) return;

        const dx = this.p1.x - this.p2.x;
        const dy = this.p1.y - this.p2.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Lógica de Ruptura
        if (dist > SETTINGS.tearDistance) {
            this.p1 = null;
            this.p2 = null;
            return;
        }

        // Lógica de Relaxamento
        const diff = (this.length - dist) / dist;
        const correction = diff * 0.5;
        const offX = dx * correction;
        const offY = dy * correction;

        if (!this.p1.pinned) {
            this.p1.x += offX;
            this.p1.y += offY;
        }
        if (!this.p2.pinned) {
            this.p2.x -= offX;
            this.p2.y -= offY;
        }
    }

    draw() {
        if (!this.p1 ||!this.p2) return;
        ctx.moveTo(this.p1.x, this.p1.y);
        ctx.lineTo(this.p2.x, this.p2.y);
    }
}

class Cloth {
    constructor(w, h) {
        // CORREÇÃO: Arrays inicializados corretamente com
        this.points =[]; 
        this.constraints =[];
        
        const startX = (width / 2) - (w * SETTINGS.spacing) / 2;
        const startY = 50;

        for (let y = 0; y <= h; y++) {
            for (let x = 0; x <= w; x++) {
                const point = new Point(startX + x * SETTINGS.spacing, startY + y * SETTINGS.spacing);
                
                // Fixa a linha superior
                if (y === 0) { 
                    point.pin(point.x, point.y); 
                } else {
                    point.x += Math.random() * 2 - 1; // Pequeno ruído inicial
                }

                this.points.push(point);

                // Conexões
                if (x > 0) {
                    this.constraints.push(new Constraint(
                        this.points[this.points.length - 1],
                        this.points[this.points.length - 2]
                    ));
                }
                if (y > 0) {
                    this.constraints.push(new Constraint(
                        this.points[this.points.length - 1],
                        this.points[x + (y - 1) * (w + 1)]
                    ));
                }
            }
        }
    }

    update() {
        for (let i = 0; i < this.points.length; i++) {
            this.points[i].update();
        }
        for (let j = 0; j < SETTINGS.stiffness; j++) {
            for (let i = 0; i < this.constraints.length; i++) {
                this.constraints[i].resolve();
            }
        }
    }

    draw() {
        ctx.beginPath();
        ctx.strokeStyle = '#4deeea';
        ctx.lineWidth = 0.5;
        const len = this.constraints.length;
        for (let i = 0; i < len; i++) {
            this.constraints[i].draw();
        }
        ctx.stroke();
    }
}

// =========================================================
// INICIALIZAÇÃO E LOOP
// =========================================================

let cloth = new Cloth(60, 40);

function animate() {
    ctx.clearRect(0, 0, width, height);

    cloth.update();
    cloth.draw();

    // Atualiza px/py do mouse para cálculo de velocidade no próximo frame
    if (mouse.x!== undefined) {
        mouse.px = mouse.x;
        mouse.py = mouse.y;
    }

    requestAnimationFrame(animate);
}

// =========================================================
// EVENTOS
// =========================================================

window.addEventListener('resize', () => {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    cloth = new Cloth(60, 40);
});

canvas.addEventListener('mousemove', (e) => {
    if (mouse.x === undefined) {
        mouse.px = e.clientX;
        mouse.py = e.clientY;
    }
    mouse.x = e.clientX;
    mouse.y = e.clientY;
});

canvas.addEventListener('mouseleave', () => {
    mouse.x = undefined;
    mouse.y = undefined;
});

canvas.addEventListener('mousedown', (e) => {
    mouse.button = e.buttons; 
});

canvas.addEventListener('mouseup', () => {
    mouse.button = 0;
});

canvas.addEventListener('contextmenu', e => e.preventDefault());

animate();

</script>
</body>
</html>